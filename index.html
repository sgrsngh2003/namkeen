<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <title>Shri Ajab Namkeen Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameCanvas {
            border: 4px solid #d4af37; /* Gold border */
            /* background: linear-gradient(to bottom, #87CEEB, #E0F7FA); */
            background-image: url('back.png'); 
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-size: cover;
        }
        
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
// ===========================
// Game Setup & Globals
// ===========================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const winnerImage = new Image();
winnerImage.src = "1.png";

const GAME_WIDTH = 800;
const GAME_HEIGHT = 480;
canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

const STATE = {
    START: 0,
    PLAYING: 1,
    GAMEOVER: 2,
    WIN: 3
};
let currentState = STATE.START;

// Tuned Physics Constants
const GRAVITY = 0.7;
const FRICTION = 0.7; // Lower = slippery, Higher = sticky (0.85 is smooth)

let score = 0;
let cameraX = 0;

const keys = {
    right: false,
    left: false,
    up: false,
    space: false
};

document.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
    if (e.code === 'Space') {
        if (currentState === STATE.PLAYING && !keys.space) {
             player.throwChappal();
        }
        keys.space = true;
    }
    
    if ((currentState === STATE.GAMEOVER || currentState === STATE.WIN) && e.code === 'Enter') {
        resetGame();
    }
    if (currentState === STATE.START && e.code === 'Enter') {
        currentState = STATE.PLAYING;
    }
});

document.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
    if (e.code === 'Space') keys.space = false;
});

// Load the Goal Image
const goalImage = new Image();
goalImage.src = "Shri-Ajab-3D-Jaipuri-Mixture.png";

// Enemy packet images (real competitor/generic namkeen packets)
const enemyImageUrls = [
    "2.png", // Bikaji Bhujia
    "3.png", // Bikaji combo
    "4.png", // Bikaji Punjabi Tadka
    "5.png", // Haldiram mix
   
];

const enemyImages = enemyImageUrls.map(url => {
    const img = new Image();
    img.crossOrigin = "anonymous"; // Helps with CORS if needed
    img.src = url;
    return img;
});

// ===========================
// Game Classes
// ===========================

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 48;
        this.velX = 0;
        this.velY = 0;
        
        // Physics variables for smoothness
        this.maxSpeed = 8;       // Max run speed
        this.acceleration = 1.5; // How fast speed builds up
        this.jumpStrength = -13;
        
        this.grounded = false;
        this.facingRight = true;
    }

    update() {
        // SMOOTH MOVEMENT LOGIC
        // Instead of setting velocity directly, we add acceleration
        
        if (keys.right) {
            if (this.velX < this.maxSpeed) {
                this.velX += this.acceleration;
            }
            this.facingRight = true;
        } 
        else if (keys.left) {
            if (this.velX > -this.maxSpeed) {
                this.velX -= this.acceleration;
            }
            this.facingRight = false;
        }

        // Apply friction every frame (creates the slide/inertia effect)
        this.velX *= FRICTION;

        // Stop completely if moving very slowly (fixes micro-sliding)
        if (Math.abs(this.velX) < 0.1) {
            this.velX = 0;
        }

        if (keys.up && this.grounded) {
            this.velY = this.jumpStrength;
            this.grounded = false;
        }

        this.velY += GRAVITY;
        
        this.x += this.velX;
        this.y += this.velY;

        if (this.y > GAME_HEIGHT + 100) {
            currentState = STATE.GAMEOVER;
        }
    }

    throwChappal() {
        const chappalX = this.x + this.width / 2;
        const chappalY = this.y + this.height / 2;
        // If moving fast, throw faster
        const bonusSpeed = this.velX * 0.5; 
        const direction = this.facingRight ? 1 : -1;
        projectiles.push(new Chappal(chappalX, chappalY, direction, bonusSpeed));
    }

    draw(cameraOffset) {
        let drawX = this.x - cameraOffset;
        let centerX = drawX + this.width / 2;
        let bottomY = this.y + this.height;

        ctx.save();
        
        // 1. Legs
        ctx.fillStyle = "#F5F5F5";
        ctx.beginPath();
        // Animate legs based on speed
        let walkOffset = 0;
        if(Math.abs(this.velX) > 0.5 && !keys.up && this.grounded) {
             walkOffset = Math.sin(Date.now() / 100) * 5;
        }
        
        ctx.ellipse(centerX - 6 + walkOffset, bottomY - 8, 5, 12, 0, 0, Math.PI * 2);
        ctx.ellipse(centerX + 6 - walkOffset, bottomY - 8, 5, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // 2. Shoes
        ctx.fillStyle = "#3E2723";
        ctx.beginPath();
        ctx.ellipse(centerX - 6 + walkOffset, bottomY - 2, 6, 3, 0, 0, Math.PI * 2);
        ctx.ellipse(centerX + 6 - walkOffset, bottomY - 2, 6, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        // 3. Body
        let grad = ctx.createLinearGradient(drawX, this.y, drawX + this.width, this.y + this.height);
        grad.addColorStop(0, "#E91E63");
        grad.addColorStop(1, "#C2185B");
        ctx.fillStyle = grad;
        
        ctx.beginPath();
        ctx.moveTo(centerX - 8, this.y + 15);
        ctx.lineTo(centerX + 8, this.y + 15);
        ctx.lineTo(centerX + 14, bottomY - 10);
        ctx.quadraticCurveTo(centerX, bottomY - 5, centerX - 14, bottomY - 10);
        ctx.lineTo(centerX - 8, this.y + 15);
        ctx.fill();

        // 4. Arms
        ctx.fillStyle = "#D2691E";
        ctx.beginPath();
        if (this.facingRight) {
             ctx.ellipse(centerX + 8, this.y + 25, 10, 3, Math.PI/6, 0, Math.PI*2);
             ctx.ellipse(centerX - 8, this.y + 25, 3, 8, 0, 0, Math.PI*2);
        } else {
             ctx.ellipse(centerX - 8, this.y + 25, 10, 3, -Math.PI/6, 0, Math.PI*2);
             ctx.ellipse(centerX + 8, this.y + 25, 3, 8, 0, 0, Math.PI*2);
        }
        ctx.fill();
        
        // Bangles
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 2;
        ctx.beginPath();
        let armX = this.facingRight ? centerX + 10 : centerX - 10;
        ctx.moveTo(armX, this.y + 22);
        ctx.lineTo(armX, this.y + 28);
        ctx.stroke();

        // 5. Head
        ctx.fillStyle = "#D2691E";
        ctx.beginPath();
        ctx.arc(centerX, this.y + 10, 10, 0, Math.PI * 2);
        ctx.fill();

        // 6. Face Details
        let eyeOffset = this.facingRight ? 3 : -3;
        ctx.fillStyle = "#FFF";
        ctx.beginPath();
        ctx.arc(centerX + eyeOffset - 2, this.y + 8, 3, 0, Math.PI * 2);
        ctx.arc(centerX + eyeOffset + 4, this.y + 8, 3, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(centerX + eyeOffset - 2, this.y + 8, 1, 0, Math.PI * 2);
        ctx.arc(centerX + eyeOffset + 4, this.y + 8, 1, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#B71C1C";
        ctx.beginPath();
        ctx.arc(centerX + eyeOffset + 1, this.y + 4, 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#5D4037";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(centerX + eyeOffset + 1, this.y + 12, 3, 0, Math.PI, false);
        ctx.stroke();

        // 7. Hair
        ctx.fillStyle = "#111";
        ctx.beginPath();
        ctx.arc(centerX, this.y + 9, 11, Math.PI, 0); 
        ctx.lineTo(centerX + 11, this.y + 14);
        ctx.quadraticCurveTo(centerX, this.y + 2, centerX - 11, this.y + 14);
        ctx.fill();
        
        ctx.beginPath();
        let braidX = this.facingRight ? centerX - 12 : centerX + 12;
        
        // Braid bounces with movement
        let bounce = Math.abs(this.velY) * 0.5;
        
        ctx.ellipse(braidX, this.y + 18 - bounce, 4, 10, this.facingRight ? Math.PI/4 : -Math.PI/4, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(braidX, this.y + 26 - bounce, 2, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

class Chappal {
    constructor(x, y, direction, bonusSpeed = 0) {
        this.x = x;
        this.y = y;
        this.width = 16;
        this.height = 16;
        this.speed = 8 + Math.abs(bonusSpeed); // Throw harder if running
        this.direction = direction;
        this.markedForDeletion = false;
        this.rotation = 0;
    }

    update() {
        this.x += this.speed * this.direction;
        this.rotation += 0.3 * this.direction;

        if (this.x < cameraX - 100 || this.x > cameraX + GAME_WIDTH + 100) {
            this.markedForDeletion = true;
        }
    }

    draw(cameraOffset) {
        let drawX = this.x - cameraOffset;
        
        ctx.save();
        ctx.translate(drawX, this.y);
        ctx.rotate(this.rotation);

        ctx.fillStyle = "#5D4037";
        ctx.beginPath();
        ctx.ellipse(0, 0, 10, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = "#FFAB00";
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(-2, -2);
        ctx.lineTo(2, 0);
        ctx.lineTo(-2, 2);
        ctx.stroke();
        
        ctx.fillStyle = "#FFAB00";
        ctx.beginPath();
        ctx.arc(2, 0, 1.5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

class Platform {
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    draw(cameraOffset) {
        // --- 1. Start Shadow Context ---
        ctx.save(); 
        
        // Configure the shadow
        ctx.shadowColor = "rgba(0, 0, 0, 0.5)"; // Black with 50% opacity
        ctx.shadowBlur = 10;                     // How fuzzy the shadow is
        ctx.shadowOffsetX = 6;                   // Horizontal shift
        ctx.shadowOffsetY = 6;                   // Vertical shift

        // Draw the main solid block (This casts the shadow)
        ctx.fillStyle = "#ffb65a";
        ctx.fillRect(this.x - cameraOffset, this.y, this.width, this.height);
        
        // --- 2. End Shadow Context ---
        // We restore here so the lines drawn below DON'T have shadows
        ctx.restore(); 

        // Draw the outlines and cracks (No shadow on these)
        ctx.strokeStyle = "#8D6E63";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.x - cameraOffset, this.y);
        ctx.lineTo(this.x - cameraOffset + this.width, this.y);
        ctx.stroke();
        
        for(let i = this.x; i < this.x + this.width; i+=40) {
             ctx.beginPath();
             ctx.moveTo(i - cameraOffset, this.y);
             ctx.lineTo(i - cameraOffset, this.y + this.height);
             ctx.stroke();
        }
    }
}

class Enemy {
    constructor(x, y, range) {
        this.x = x;
        this.y = y;
        this.width = 70;  // Larger for better image fit
        this.height = 70;
        this.startX = x;
        this.range = range;
        this.speed = 2;
        this.direction = 1;
        this.markedForDeletion = false;
        
        // Random real competitor packet image
        this.image = enemyImages[Math.floor(Math.random() * enemyImages.length)];
    }

    update() {
        this.x += this.speed * this.direction;
        if (this.x > this.startX + this.range || this.x < this.startX) {
            this.direction *= -1;
        }
    }

    draw(cameraOffset) {
        let drawX = this.x - cameraOffset;
        
        if (this.image.complete && this.image.naturalHeight !== 0) {
            ctx.drawImage(this.image, drawX, this.y, this.width, this.height);
        } else {
            // Fallback to colored box
            ctx.fillStyle = Math.random() > 0.5 ? "#E91E63" : "#FF5722";
            ctx.fillRect(drawX, this.y, this.width, this.height);
            
            ctx.fillStyle = "#FFF";
            ctx.font = "bold 10px Arial";
            ctx.textAlign = "center";
            ctx.fillText("OTHER BRAND", drawX + this.width/2, this.y + this.height/2);
            ctx.textAlign = "left";
        }
    }
}
class ShriAjabGoal {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 60;
        this.height = 40;
    }
    
    draw(cameraOffset) {
        let drawX = this.x - cameraOffset;
        
        // 1. Draw the main goal packet (or fallback box)
        if (goalImage.complete && goalImage.naturalHeight !== 0) {
            ctx.drawImage(goalImage, drawX, this.y, this.width, this.height);
        } else {
            // Fallback if image fails
            ctx.fillStyle = "transparent";
            ctx.fillRect(drawX, this.y, this.width, this.height);
            ctx.fillStyle = "transparent";
            ctx.fillRect(drawX, this.y + 10, this.width, 20);
        }
        
        // Calculate the top position of the floating logo image
        // We place it 40px above the main packet.
        let logoTopY = this.y - 40;

        // 2. Draw the floating winner logo image
        if (winnerImage.complete && winnerImage.naturalHeight !== 0) {
            ctx.drawImage(
                winnerImage,
                drawX - 10,       // center horizontally relative to packet
                logoTopY,         // Y position calculated above
                80,               // width
                80                // height
            );
        }

        ctx.save(); 
        ctx.fillStyle = "#FFD700"; // Gold color
        ctx.font = "bold 16px 'Press Start 2P'";
        ctx.textAlign = "center";
        ctx.shadowColor = "rgba(0,0,0,0.8)"; // Add a small shadow to make text pop
        ctx.shadowBlur = 4;
        
        // Position: Center horizontally, 15px above the top of the logo image
        ctx.fillText("WINNER", drawX + this.width / 2, logoTopY - 15);
        
        ctx.restore(); // Restore settings
    }
}
class Decoration {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
    }
    draw(cameraOffset) {
        ctx.fillStyle = "#A1887F";
        if(this.type === 'arch') {
             ctx.beginPath();
             ctx.arc(this.x - cameraOffset, this.y, 40, Math.PI, 0);
             ctx.fill();
             ctx.fillRect(this.x - 40 - cameraOffset, this.y, 10, 60);
             ctx.fillRect(this.x + 30 - cameraOffset, this.y, 10, 60);
        }
    }
}

// ===========================
// Initialization, Logic, Draw, Loop
// ===========================

let player;
let platforms = [];
let enemies = [];
let projectiles = [];
let decorations = [];
let goal;
function initGame() {
    score = 0;
    cameraX = 0;
    // Reset player position
    player = new Player(100, GAME_HEIGHT - 150);
    projectiles = [];
    
    // --- PLATFORMS ---
    // Define platforms first so we know their Y positions
    // Ground level Y is: GAME_HEIGHT - 40
    // Tier 1 Y is: GAME_HEIGHT - 120
    // Tier 2 Y is: GAME_HEIGHT - 150
    // Tier 3 Y is: GAME_HEIGHT - 250
    platforms = [
        new Platform(0, GAME_HEIGHT - 40, 1000, 40),
        new Platform(1100, GAME_HEIGHT - 40, 800, 40),
        new Platform(2000, GAME_HEIGHT - 40, 1000, 40),
        
        new Platform(300, GAME_HEIGHT - 120, 150, 30),
        new Platform(500, GAME_HEIGHT - 200, 150, 30),
        new Platform(700, GAME_HEIGHT - 120, 150, 30),
        
        new Platform(1200, GAME_HEIGHT - 150, 200, 30),
        new Platform(1500, GAME_HEIGHT - 250, 200, 30),
        new Platform(1800, GAME_HEIGHT - 150, 150, 30),
        
        new Platform(2200, GAME_HEIGHT - 150, 100, 30),
        new Platform(2400, GAME_HEIGHT - 250, 100, 30),
        new Platform(2600, GAME_HEIGHT - 350, 300, 40)
    ];

    // --- ENEMIES ---
    // Enemy height is fixed at 70 in the Enemy class constructor.
    // To place them ON a platform, the formula is: Platform Y - 70.

    enemies = [
        // Enemy 1: On ground (Platform Y = GAME_HEIGHT - 40)
        // Y = (GAME_HEIGHT - 40) - 70 = GAME_HEIGHT - 110
        new Enemy(400, GAME_HEIGHT - 110, 200),

        // Enemy 2: On platform (Platform Y = GAME_HEIGHT - 150)
        // Y = (GAME_HEIGHT - 150) - 70 = GAME_HEIGHT - 220
        new Enemy(1200, GAME_HEIGHT - 220, 150),

        // Enemy 3: On higher platform (Platform Y = GAME_HEIGHT - 250)
        // Y = (GAME_HEIGHT - 250) - 70 = GAME_HEIGHT - 320
        new Enemy(1600, GAME_HEIGHT - 320, 100),

        // Enemy 4: On ground later in level
        new Enemy(2100, GAME_HEIGHT - 110, 300)
    ];
    
    decorations = [
        new Decoration(200, GAME_HEIGHT-80, 'arch'),
        new Decoration(600, GAME_HEIGHT-80, 'arch'),
        new Decoration(1400, GAME_HEIGHT-80, 'arch'),
        new Decoration(2300, GAME_HEIGHT-80, 'arch'),
    ];

    
    goal = new ShriAjabGoal(2750, GAME_HEIGHT - 390);
}

function resetGame() {
    currentState = STATE.START;
    initGame();
}

function checkCollision(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function update() {
    if (currentState !== STATE.PLAYING) return;

    player.update();
    
    player.grounded = false;
    for (const plat of platforms) {
        if (checkCollision(player, plat)) {
            if (player.velY > 0 && player.y + player.height - player.velY <= plat.y) {
                player.grounded = true;
                player.velY = 0;
                player.y = plat.y - player.height;
            }
            else if (player.velY < 0 && player.y - player.velY >= plat.y + plat.height) {
                 player.velY = 0;
                 player.y = plat.y + plat.height;
            }
        }
    }
    
    for (const plat of platforms) {
        if (checkCollision(player, plat)) {
            if(player.velX > 0 && player.x + player.width - player.velX <= plat.x) {
                 player.x = plat.x - player.width;
                 player.velX = 0;
            }
            else if(player.velX < 0 && player.x - player.velX >= plat.x + plat.width) {
                 player.x = plat.x + plat.width;
                 player.velX = 0;
            }
        }
     }

    projectiles.forEach(p => p.update());

    enemies.forEach(e => e.update());

    projectiles.forEach(chappal => {
        enemies.forEach(enemy => {
            if (!chappal.markedForDeletion && !enemy.markedForDeletion && checkCollision(chappal, enemy)) {
                enemy.markedForDeletion = true;
                chappal.markedForDeletion = true;
                score += 100;
            }
        });
    });

    enemies.forEach(enemy => {
        if (!enemy.markedForDeletion && checkCollision(player, enemy)) {
            currentState = STATE.GAMEOVER;
        }
    });
    
    if(checkCollision(player, goal)) {
        currentState = STATE.WIN;
        score += 1000;
    }

    projectiles = projectiles.filter(p => !p.markedForDeletion);
    enemies = enemies.filter(e => !e.markedForDeletion);

    // SMOOTH CAMERA LOGIC (LERP)
    // Instead of locking directly, we move 10% towards the player every frame
    let targetCameraX = player.x - GAME_WIDTH * 0.4; // Keep player roughly in 40% of screen
    
    // Limits
    if(targetCameraX < 0) targetCameraX = 0;
    
    // Smooth transition
    cameraX += (targetCameraX - cameraX) * 0.1;
}

function drawUI() {
    ctx.fillStyle = "#000";
    ctx.font = "20px Arial";
    ctx.fillText("Score: " + score, 20, 30);
}

function drawOverlay(title, subtitle) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    
    ctx.fillStyle = "#FFC107";
    ctx.textAlign = "center";
    ctx.font = "bold 40px Arial";
    ctx.fillText(title, GAME_WIDTH / 2, GAME_HEIGHT / 2 - 20);
    
    ctx.fillStyle = "#FFF";
    ctx.font = "20px Arial";
    ctx.fillText(subtitle, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);
    ctx.textAlign = "left";
}

function draw() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (currentState === STATE.START) {
        drawOverlay("SHRI AJAB ADVENTURE", "Press ENTER to Start. Controls: Arrows to Move/Jump, SPACE to Throw Chappal.");
        return;
    }

    decorations.forEach(d => d.draw(cameraX));
    platforms.forEach(p => p.draw(cameraX));
    goal.draw(cameraX);
    enemies.forEach(e => e.draw(cameraX));
    projectiles.forEach(p => p.draw(cameraX));
    player.draw(cameraX);

    drawUI();

    if (currentState === STATE.GAMEOVER) {
        drawOverlay("GAME OVER", "The generic brands won. Press ENTER to restart.");
    } else if (currentState === STATE.WIN) {
        drawOverlay("YOU WIN!", "You collected the Shri Ajab Namkeen! Final Score: " + score + ". Press Enter to play again.");
    }
}

initGame();

function gameLoop(timestamp) {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

</script>
</body>
</html>
